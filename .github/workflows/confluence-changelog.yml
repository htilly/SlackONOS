name: Publish Changelog to Confluence

on:
  release:
    types: [published]
  
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to test (e.g., v1.7.3)'
        required: true
        default: 'v1.7.3'
      dry_run:
        description: 'Dry run (log only, skip Confluence API call)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  publish-changelog:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Get release info
      id: release
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual trigger - use input values
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "name=SlackONOS ${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "url=https://github.com/htilly/SlackONOS/releases/tag/${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT
          echo "(Manual test run)" > release_body.txt
        else
          # Release trigger
          echo "version=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          echo "name=${{ github.event.release.name }}" >> $GITHUB_OUTPUT
          echo "url=${{ github.event.release.html_url }}" >> $GITHUB_OUTPUT
          echo "dry_run=false" >> $GITHUB_OUTPUT
          cat << 'EOF' > release_body.txt
        ${{ github.event.release.body }}
        EOF
        fi
    
    - name: Extract changelog for this version
      id: changelog
      run: |
        VERSION="${{ github.event.release.tag_name }}"
        # Remove 'v' prefix if present
        VERSION_NUM="${VERSION#v}"
        
        # Try to extract the changelog section for this version
        # Look for the version header and extract until the next version header
        CHANGELOG_SECTION=$(awk "/## \[${VERSION_NUM}\]/{found=1; next} /## \[/{if(found) exit} found{print}" CHANGELOG.md)
        
        if [ -z "$CHANGELOG_SECTION" ]; then
          # Fallback to release body if no changelog section found
          CHANGELOG_SECTION=$(cat release_body.txt)
        fi
        
        # Save to file for the API call
        echo "$CHANGELOG_SECTION" > changelog_section.txt
        
    - name: Create Confluence page
      shell: bash {0}
      env:
        CONFLUENCE_BASE_URL: https://htilly.atlassian.net/wiki
        CONFLUENCE_SPACE_KEY: "~5570587e5fa4f786c64409a23448de7e84a65c"
        CONFLUENCE_PARENT_PAGE_ID: "753665"
        CONFLUENCE_USER: ${{ secrets.CONFLUENCE_USER }}
        CONFLUENCE_API_TOKEN: ${{ secrets.CONFLUENCE_API_TOKEN }}
        DRY_RUN: ${{ steps.release.outputs.dry_run }}
      run: |
        set -o pipefail
        VERSION="${{ steps.release.outputs.version }}"
        RELEASE_DATE=$(date +%Y-%m-%d)
        RELEASE_URL="${{ steps.release.outputs.url }}"
        
        CHANGELOG_CONTENT=$(cat changelog_section.txt)
        
        # Convert markdown to Confluence storage format (basic conversion)
        # Replace ### with h3, ## with h2, etc.
        CONFLUENCE_BODY=$(echo "$CHANGELOG_CONTENT" | \
          sed 's/^### \(.*\)/<h3>\1<\/h3>/g' | \
          sed 's/^## \(.*\)/<h2>\1<\/h2>/g' | \
          sed 's/^- \(.*\)/<li>\1<\/li>/g' | \
          sed 's/\*\*\([^*]*\)\*\*/<strong>\1<\/strong>/g' | \
          sed 's/`\([^`]*\)`/<code>\1<\/code>/g' | \
          tr '\n' ' ' | \
          sed 's/<li>/<ul><li>/1' | \
          sed 's/<\/li> *$/<\/li><\/ul>/' | \
          sed 's/<\/li> *<li>/<\/li><li>/g')
        
        # Build the page content
        PAGE_CONTENT="<h2>Release Information</h2>
        <table>
          <tr><th>Version</th><td>${VERSION}</td></tr>
          <tr><th>Release Date</th><td>${RELEASE_DATE}</td></tr>
          <tr><th>GitHub Release</th><td><a href=\"${RELEASE_URL}\">${RELEASE_URL}</a></td></tr>
        </table>
        <h2>Changes</h2>
        ${CONFLUENCE_BODY}
        <hr/>
        <p><em>This page was automatically generated from the <a href=\"https://github.com/htilly/SlackONOS\">SlackONOS</a> GitHub release.</em></p>"
        
        if [ "$DRY_RUN" = "true" ]; then
          echo "ðŸ§ª DRY RUN - Would create: SlackONOS ${VERSION} - ${RELEASE_DATE}"
          exit 0
        fi
        
        # Check if secrets are configured
        if [ -z "$CONFLUENCE_USER" ] || [ -z "$CONFLUENCE_API_TOKEN" ]; then
          echo "âŒ ERROR: Confluence secrets not configured"
          exit 1
        fi
        
        # Build JSON payload using jq
        JSON_PAYLOAD=$(jq -n \
          --arg type "page" \
          --arg title "SlackONOS ${VERSION} - ${RELEASE_DATE}" \
          --arg parentId "${CONFLUENCE_PARENT_PAGE_ID}" \
          --arg spaceKey "${CONFLUENCE_SPACE_KEY}" \
          --arg bodyValue "$PAGE_CONTENT" \
          '{
            type: $type,
            title: $title,
            ancestors: [{id: $parentId}],
            space: {key: $spaceKey},
            body: {
              storage: {
                value: $bodyValue,
                representation: "storage"
              }
            }
          }')

        
        # Write payload to temp file to avoid shell escaping issues
        echo "$JSON_PAYLOAD" > /tmp/confluence_payload.json
        
        # Pre-compute auth header
        AUTH_HEADER=$(printf '%s:%s' "${CONFLUENCE_USER}" "${CONFLUENCE_API_TOKEN}" | base64 | tr -d '\n')
        
        # Create Confluence page
        echo "ðŸ“¤ Creating Confluence page for ${VERSION}..."
        
        # Write response to file to avoid any shell escaping issues
        HTTP_CODE=$(curl -s -o /tmp/response.json -w "%{http_code}" -X POST \
          -H "Authorization: Basic ${AUTH_HEADER}" \
          -H "Content-Type: application/json" \
          -H "Accept: application/json" \
          "${CONFLUENCE_BASE_URL}/rest/api/content" \
          --data-binary @/tmp/confluence_payload.json)
        CURL_EXIT=$?
        
        if [ $CURL_EXIT -ne 0 ]; then
          echo "âŒ Request failed (curl exit: $CURL_EXIT)"
          cat /tmp/response.json 2>/dev/null
          exit 1
        fi
        
        # Read response from file
        HTTP_BODY=$(cat /tmp/response.json)
        
        if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
          PAGE_URL=$(echo "$HTTP_BODY" | jq -r '._links.base + ._links.webui // empty' 2>/dev/null)
          echo "âœ… Confluence page created for ${VERSION}"
          if [ -n "$PAGE_URL" ]; then
            echo "ðŸ”— Page URL: ${PAGE_URL}"
          fi
        else
          echo "âŒ Failed (HTTP ${HTTP_CODE}):"
          echo "$HTTP_BODY" | jq . 2>/dev/null || echo "$HTTP_BODY"
          exit 1
        fi
