name: Publish Changelog to Confluence

on:
  release:
    types: [published]
  
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to test (e.g., v1.7.3)'
        required: true
        default: 'v1.7.3'
      dry_run:
        description: 'Dry run (log only, skip Confluence API call)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  publish-changelog:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Get release info
      id: release
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual trigger - use input values
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "name=SlackONOS ${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "url=https://github.com/htilly/SlackONOS/releases/tag/${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT
          echo "(Manual test run)" > release_body.txt
        else
          # Release trigger
          echo "version=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          echo "name=${{ github.event.release.name }}" >> $GITHUB_OUTPUT
          echo "url=${{ github.event.release.html_url }}" >> $GITHUB_OUTPUT
          echo "dry_run=false" >> $GITHUB_OUTPUT
          cat << 'EOF' > release_body.txt
        ${{ github.event.release.body }}
        EOF
        fi
    
    - name: Extract changelog for this version
      id: changelog
      run: |
        VERSION="${{ github.event.release.tag_name }}"
        # Remove 'v' prefix if present
        VERSION_NUM="${VERSION#v}"
        
        # Try to extract the changelog section for this version
        # Look for the version header and extract until the next version header
        CHANGELOG_SECTION=$(awk "/## \[${VERSION_NUM}\]/{found=1; next} /## \[/{if(found) exit} found{print}" CHANGELOG.md)
        
        if [ -z "$CHANGELOG_SECTION" ]; then
          # Fallback to release body if no changelog section found
          CHANGELOG_SECTION=$(cat release_body.txt)
        fi
        
        # Save to file for the API call
        echo "$CHANGELOG_SECTION" > changelog_section.txt
        
    - name: Create Confluence page
      env:
        CONFLUENCE_BASE_URL: https://htilly.atlassian.net/wiki
        CONFLUENCE_SPACE_KEY: "~5570587e5fa4f786c64409a23448de7e84a65c"
        CONFLUENCE_PARENT_PAGE_ID: "753665"
        CONFLUENCE_USER: ${{ secrets.CONFLUENCE_USER }}
        CONFLUENCE_API_TOKEN: ${{ secrets.CONFLUENCE_API_TOKEN }}
        DRY_RUN: ${{ steps.release.outputs.dry_run }}
      run: |
        VERSION="${{ steps.release.outputs.version }}"
        RELEASE_DATE=$(date +%Y-%m-%d)
        RELEASE_URL="${{ steps.release.outputs.url }}"
        
        # Read changelog content
        CHANGELOG_CONTENT=$(cat changelog_section.txt)
        
        echo "üìã Changelog content for ${VERSION}:"
        echo "---"
        cat changelog_section.txt
        echo "---"
        
        # Convert markdown to Confluence storage format (basic conversion)
        # Replace ### with h3, ## with h2, etc.
        CONFLUENCE_BODY=$(echo "$CHANGELOG_CONTENT" | \
          sed 's/^### \(.*\)/<h3>\1<\/h3>/g' | \
          sed 's/^## \(.*\)/<h2>\1<\/h2>/g' | \
          sed 's/^- \(.*\)/<li>\1<\/li>/g' | \
          sed 's/\*\*\([^*]*\)\*\*/<strong>\1<\/strong>/g' | \
          sed 's/`\([^`]*\)`/<code>\1<\/code>/g' | \
          tr '\n' ' ' | \
          sed 's/<li>/<ul><li>/1' | \
          sed 's/<\/li> *$/<\/li><\/ul>/' | \
          sed 's/<\/li> *<li>/<\/li><li>/g')
        
        # Build the page content
        PAGE_CONTENT="<h2>Release Information</h2>
        <table>
          <tr><th>Version</th><td>${VERSION}</td></tr>
          <tr><th>Release Date</th><td>${RELEASE_DATE}</td></tr>
          <tr><th>GitHub Release</th><td><a href=\"${RELEASE_URL}\">${RELEASE_URL}</a></td></tr>
        </table>
        <h2>Changes</h2>
        ${CONFLUENCE_BODY}
        <hr/>
        <p><em>This page was automatically generated from the <a href=\"https://github.com/htilly/SlackONOS\">SlackONOS</a> GitHub release.</em></p>"
        
        echo ""
        echo "üìÑ Generated Confluence page content:"
        echo "---"
        echo "$PAGE_CONTENT"
        echo "---"
        
        if [ "$DRY_RUN" = "true" ]; then
          echo ""
          echo "üß™ DRY RUN MODE - Skipping Confluence API call"
          echo "Would create page: SlackONOS ${VERSION} - ${RELEASE_DATE}"
          echo "Parent page ID: ${CONFLUENCE_PARENT_PAGE_ID}"
          echo "Space key: ${CONFLUENCE_SPACE_KEY}"
          exit 0
        fi
        
        # Check if secrets are configured
        if [ -z "$CONFLUENCE_USER" ] || [ -z "$CONFLUENCE_API_TOKEN" ]; then
          echo "‚ùå ERROR: CONFLUENCE_USER and/or CONFLUENCE_API_TOKEN secrets are not configured!"
          echo "Please add these secrets in GitHub repository settings."
          exit 1
        fi
        
        # Escape for JSON
        PAGE_CONTENT_ESCAPED=$(echo "$PAGE_CONTENT" | jq -Rs .)
        
        echo ""
        echo "üîó Calling Confluence API..."
        echo "   URL: ${CONFLUENCE_BASE_URL}/rest/api/content"
        echo "   Space: ${CONFLUENCE_SPACE_KEY}"
        echo "   Parent Page ID: ${CONFLUENCE_PARENT_PAGE_ID}"
        echo ""
        
        # Build JSON payload using jq to ensure proper formatting
        JSON_PAYLOAD=$(jq -n \
          --arg type "page" \
          --arg title "SlackONOS ${VERSION} - ${RELEASE_DATE}" \
          --arg parentId "${CONFLUENCE_PARENT_PAGE_ID}" \
          --arg spaceKey "${CONFLUENCE_SPACE_KEY}" \
          --arg bodyValue "$PAGE_CONTENT" \
          '{
            type: $type,
            title: $title,
            ancestors: [{id: $parentId}],
            space: {key: $spaceKey},
            body: {
              storage: {
                value: $bodyValue,
                representation: "storage"
              }
            }
          }')
        
        # Write payload to temp file to avoid shell escaping issues
        echo "$JSON_PAYLOAD" > /tmp/confluence_payload.json
        
        # Create the page via Confluence REST API - capture both response and HTTP code
        HTTP_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST \
          -H "Authorization: Basic $(echo -n "${CONFLUENCE_USER}:${CONFLUENCE_API_TOKEN}" | base64)" \
          -H "Content-Type: application/json" \
          -H "Accept: application/json" \
          "${CONFLUENCE_BASE_URL}/rest/api/content" \
          -d @/tmp/confluence_payload.json)
        
        # Extract the body and status code
        HTTP_BODY=$(echo "$HTTP_RESPONSE" | sed -e 's/HTTPSTATUS\:.*//g')
        HTTP_STATUS=$(echo "$HTTP_RESPONSE" | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
        
        echo "üì® API Response (HTTP ${HTTP_STATUS}):"
        echo "$HTTP_BODY" | jq . 2>/dev/null || echo "$HTTP_BODY"
        echo ""
        
        if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
          PAGE_URL=$(echo "$HTTP_BODY" | jq -r '._links.base + ._links.webui // empty' 2>/dev/null)
          echo "‚úÖ Confluence page created for ${VERSION}"
          if [ -n "$PAGE_URL" ]; then
            echo "üîó Page URL: ${PAGE_URL}"
          fi
        else
          echo "‚ùå Failed to create Confluence page (HTTP ${HTTP_STATUS})"
          exit 1
        fi
